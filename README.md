# LLVM to Apple Intermediate Representation (AIR) Translator

This repository implements a lightweight compiler backend for translating standard, device-agnostic LLVM IR into Apple Metal AIR (`.metallib`), bypassing the proprietary Metal Language frontend. This enables direct execution of LLVM IR generated by external compilers (e.g., MLIR, Rust, TinyGrad) on Apple Silicon GPUs.

## Architectural Overview

Apple Metal AIR is a derivative of LLVM bitcode (based on LLVM 11-14) that enforces specific conventions regarding address spaces, pointer typing, and metadata schemas. This project provides a transformation layer, `air_forge.py`, which normalizes generic LLVM IR to conform to the AIR specification.

### Transformation Pipeline

The translation process consists of four passes:

1.  **Target Reparameterization**:
    *   **Triple**: Rewritten to `air64_v27-apple-macosx15.0.0`.
    *   **Data Layout**: Enforces `e-p:64:64:64-...` to match the Apple Silicon memory model.

2.  **Type & Address Space Lowering**:
    *   **Typed Pointers**: Reconstructs explicit pointer types (e.g., `float*`) from opaque pointers (`ptr`), as AIR does not support opaque pointers.
    *   **Address Space Mapping**:
        *   Generic `float*` $\rightarrow$ `float addrspace(1)*` (Device/Global).
        *   Generic `shared float*` $\rightarrow$ `float addrspace(3)*` (Threadgroup).
    *   **Propagation**: Implements a recursive SSA-use-def chain traversal to propagate address spaces through `getelementptr`, `bitcast`, and `load`/`store` instructions.

3.  **Intrinsic Lowering**:
    *   Maps generic synchronization primitives (e.g., `@barrier()`) to Metal-specific intrinsics.
    *   **Example**: `call void @barrier()` $\rightarrow$ `tail call void @air.wg.barrier(i32 2, i32 1)`.

4.  **Metadata Synthesis**:
    *   Injects the `!air.kernel` named metadata tree required by the Metal driver for pipeline state creation.
    *   Generates `!air.buffer` nodes with `air.location_index` to map function arguments to Metal buffer binding slots (`[[buffer(n)]]`).
    *   Generates `!air.thread_position_in_grid` and `!air.thread_position_in_threadgroup` for implicit thread ID arguments.

## Usage

### Prerequisites
*   macOS (Sonoma 14+ recommended)
*   Xcode Command Line Tools
*   Python 3

### Workflow

1.  **Input Generation**: Produce standard LLVM IR (`input.ll`).
    ```llvm
    define void @kernel(float* %in, float* %out, i32 %id) { ... }
    ```

2.  **Translation**:
    ```bash
    python3 air_forge.py input.ll > forged.ll
    ```

3.  **Assembly & Linkage**: Use the Apple standard toolchain for final bitcode generation.
    ```bash
    xcrun -sdk macosx metal -c forged.ll -o forged.air
    xcrun -sdk macosx metallib forged.air -o forged.metallib
    ```

4.  **Execution**: Load resulting `.metallib` via `MTLDevice.newLibraryWithURL`.

## Technical Specifications

### Address Space Mapping

| LLVM Address Space | Metal Memory Space | Description |
|--------------------|--------------------|-------------|
| `0` (Default)      | N/A                | Generic path; rewritten by compiler. |
| `1`                | Device             | Global buffers (`[[buffer(n)]]`). |
| `3`                | Threadgroup        | Shared memory (`[[threadgroup(n)]]`). |

### Metadata Schema

The driver validates the `!air.kernel` metadata tree against the kernel signature. A valid entry point requires:

```llvm
!air.kernel = !{!0}
!0 = !{void (...)* @main, !1, !2}
!2 = !{!3} ; Argument Metadata
!3 = !{i32 0, !"air.buffer", !"air.location_index", i32 0, ...}
```

*   `air.location_index`: Corresponds to the Metal binding slot index.
*   `air.address_space`: Must match the pointer address space of the argument.

### Supported Intrinsics

| Generic Operation | Metal Intrinsic | Signature |
|-------------------|-----------------|-----------|
| Workgroup Barrier | `@air.wg.barrier` | `void (i32, i32)` |

## Repository Structure

*   `air_forge.py`: Core translation logic.
*   `tests/`: Canonical integration tests.
    *   `input.ll`: Reference IR containing shared memory and barriers.
    *   `verify.mm`: Metal/C++ harness for functional verification.
*   `demo.sh`: Validation script executing the full pipeline.

## Limitations

*   **Struct Arguments**: Support limited to scalar and pointer arguments.
*   **Textures**: `addrspace(2)` texture mapping is unimplemented.
*   **Control Flow**: Address space propagation currently relies on basic use-def chains; complex loop-carried dependencies via `phi` nodes may require enhanced flow analysis.
